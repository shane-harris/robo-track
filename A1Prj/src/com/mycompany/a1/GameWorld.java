package com.mycompany.a1;

import java.io.OutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Random;

import com.codename1.components.ToastBar;
import com.codename1.messaging.Message;
import com.codename1.ui.Form;
import com.codename1.ui.Label;
import com.codename1.ui.geom.Point2D;
import com.codename1.ui.layouts.BoxLayout;

public class GameWorld extends Form{
	private ArrayList<GameObject> gameObjects;
	private double width;
	private double height;
	private double originX;
	private double originY;
	private Point2D point;
	private int clock;
	private int lives;
	private Random random = new Random();
	private EnergyStation energyStation;
	private Drone drone;
	private Base base;

	public GameWorld() {
		this.width = 1024.0;
		this.height = 768.0;
		this.originX = 0.0;
		this.originY = 0.0;
		this.lives = 3;
		this.clock = 0;
		this.point = new Point2D(originX, originY);

	}

	public void init() {
		gameObjects = new ArrayList<GameObject>();

		gameObjects.add(Robot.getRobot());
		for (int i = 0; i < random.nextInt(5) + 1; i++) {
			drone = new Drone();
			gameObjects.add(drone);
		}

		for (int i = 0; i < random.nextInt(6) + 1; i++) {
			energyStation = new EnergyStation();
			gameObjects.add(energyStation);
		}
		base = new Base(point, 1);
		gameObjects.add(base);

		point = new Point2D(110, 131);
		base = new Base(point, 2);
		gameObjects.add(base);

		point = new Point2D(200, 191);
		base = new Base(point, 3);
		gameObjects.add(base);

		point = new Point2D(321, 331);
		base = new Base(point, 4);
		gameObjects.add(base);

		point = new Point2D(610, 631);
		base = new Base(point, 5);
		gameObjects.add(base);

	}
	
	public int getClock(){
		return this.clock;
	}
	public int getLives(){
		return this.lives;
	}

	public void tick() {
		/*
		 * ‘t’ – tell the game world that the “game clock” has ticked. A clock tick in
		 * the game world has the following effects: (1) if the player robot moves
		 * (e.g., did not run out of energy or does not have the maximum damage or zero
		 * speed), then the robot’s heading should be incremented or decremented by the
		 * robot’s steeringDirection (that is, the steering wheel turns the robot) (2)
		 * Drones also update their heading as indicated above. (3) all moveable objects
		 * are told to update their positions according to their current heading and
		 * speed, and (4) the robot’s energy level is reduced by the amount indicated by
		 * its energyConsumptionRate. (5) the elapsed time “game clock” is incremented
		 * by one (the game clock for this assignment is simply a variable which
		 * increments with each tick)
		 */

		// Game world has ticked
		clock++;

		for (GameObject gO : gameObjects) {
			if (gO instanceof Moveable) {
				((Moveable) gO).move(); // move sets location no need to call setLocation()
			}
			if (gO instanceof Robot) {
				((Robot) gO).consumeEnergy(); // energy consumed after move
			}
			if (gO instanceof Drone) {
				((Drone) gO).randomHeading();// aulters Drone heading after move
			}
			if (gO instanceof EnergyStation) {

			}
			if (gO instanceof Base) {

			}
		}

	}

	public void display() {
		/*
		 * ‘d’ – generate a display by outputting lines of text on the console
		 * describing the current game/player-robot state values. The display should
		 * include (1) the number of lives left, (2) the current clock value (elapsed
		 * time), (3) the highest base number the robot has reached sequentially so far,
		 * (4) the robot’s current energy level and (5) robot’s current damage level.
		 * All output should be appropriately labeled in easily readable format.
		 */
		/*Message display = new Message("This is a test");
		OutputStream mess = "Please work";
		PrintStream test = new PrintStream(mess);*/
		
		/*Form message = new Form();
        message.add(new Label("Hope this works"));
        //message.getToolbar().setTitleCentered(true);
        message.show();*/
        /*Label again = new Label("Try this now");
        this.addComponent(again);
        //this.show();
        this.showNativeOverlay();*/
		String displayAll="";
		displayAll += "Lives= " + this.getLives() +" , ";
		displayAll += "Clock= " + this.getClock() +"\n";
		for(GameObject robot : gameObjects) {
			if(robot instanceof Robot) {
				displayAll += "Highest Base Reached= "+((Robot) robot).getLastBaseReached()+"\n";
				displayAll += "Robot Energy Level = "+((Robot) robot).getEnergyLevel()+"% \n";
				displayAll += "Robot Damage Level = "+((Robot) robot).getDamageLevel()+"% \n";
			}
		}
		ToastBar.setDefaultMessageTimeout(20000);
        ToastBar.showInfoMessage(displayAll);
        ToastBar.setDefaultMessageTimeout(5000);
        System.out.println(displayAll);
		

	}

	public void map() {
		/*
		 * ‘m’ – tell the game world to output a “map” showing the current worl For this
		 * assignment all output will be in text form on the console; no “graphical”
		 * output is required. The “map” (generated by the ‘m’ command) will simply be a
		 * set of lines describing the objects currently in the world, similar to the
		 * following: Base: loc=200.0,200.0 color=[0,0,255] size=10 seqNum=1 Base:
		 * loc=200.0,800.0 color=[0,0,255] size=10 seqNum=2 Base: loc=700.0,800.0
		 * color=[0,0,255] size=10 seqNum=3 Base: loc=900.0,400.0 color=[0,0,255]
		 * size=10 seqNum=4 Robot: loc=180.2,450.3 color=[255,0,0] heading=355 speed=50
		 * size=40 maxSpeed=50 steeringDirection=5 energyLevel=5 damageLevel=2 Drone:
		 * loc=70.3,70.7 color=[255,0,255] heading=45 speed=5 size=25 Drone:
		 * loc=950.6,950.3 color=[255,0,255] heading=225 speed=10 size=20 EnergyStation:
		 * loc=350.8,350.6 color=[0,255,0] size=15 capacity=15 EnergyStation:
		 * loc=900.0,700.4 color=[0,255,0] size=20 capacity=20
		 * 
		 * Note that the above “map” describes the game shortly after it has started;
		 * the robot has moved northward from its initial position at base #1, the robot
		 * is traveling at its maximum speed, the player is trying to apply a 5-degree
		 * right turn, and so forth. Note also that the appropriate mechanism for
		 * implementing this output is to override the toString() method in each
		 * concrete game object class so that it returns a String describing itself (see
		 * the “Appendix – CN1 Notes” below). Please see “Appendix – CN1 Notes” below
		 * for also tips on how to print one digit after a decimal point in CN1.
		 */
		
		String displayAll ="";
		for(GameObject gO : gameObjects) {
			displayAll += gO.toString();
		}
        ToastBar.setDefaultMessageTimeout(20000);
        ToastBar.showInfoMessage(displayAll);
        ToastBar.setDefaultMessageTimeout(2000);
        System.out.println(displayAll);

	}

	public void update() {

	}

	public void accelerate() {
		/*
		 * ‘a’ – tell the game world to accelerate (immediately increase the speed of)
		 * the player robot by a small amount. Note that the effect of acceleration is
		 * to be limited based on damage level, energy level, and maximum speed as
		 * described above.
		 */
		int accelerationAmmount = 5; // ammount can be adjusted to tweak game play
		for (GameObject gO : gameObjects) {
			if (gO instanceof Robot) {
				((Robot) gO).accelorateRobot(accelerationAmmount);
				System.out.println("Robot speed is = "+((Robot) gO).getSpeed());
			}
		}
		
	}

	public void brake() {
		/*
		 * ‘b’ – tell the game world to brake (immediately reduce the speed of) the
		 * player robot by a small amount. Note that the minimum speed for a robot is
		 * zero.
		 */
		int accelerationAmmount = -5; // ammount can be adjusted to tweak game play
		for (GameObject gO : gameObjects) {
			if (gO instanceof Robot)
				((Robot) gO).accelorateRobot(accelerationAmmount);
		}
	}

	public void steerRight() {
		/*
		 * ‘r’ – tell the game world to change the steering direction of the player
		 * robot by 5 degrees to the right (in the positive direction on the compass).
		 * As above, this changes the direction of the robot’s steering wheel, not the
		 * robot’s heading
		 */
		int adjustHeadingAmmount = 5; // ammount can be adjusted to tweak game play
		for (GameObject gO : gameObjects) {
			if (gO instanceof Robot)
				((Robot) gO).steer(adjustHeadingAmmount);
		}

	}

	public void steerLeft() {
		/*
		 * Should call a method in the Robot object that steers left... ‘l’ (the letter
		 * “ell”) – tell the game world to change the steering direction of the player
		 * robot by 5 degrees to the left (in the negative direction on the compass).
		 * Note that this changes the direction of the robot’s steering wheel; it does
		 * not directly (immediately) affect the robot’s heading. See the “tick”
		 * command, below.
		 */
		int adjustHeadingAmmount = -5; // ammount can be adjusted to tweak game play
		for (GameObject gO : gameObjects) {
			if (gO instanceof Robot)
				((Robot) gO).steer(adjustHeadingAmmount);
		}
	}

	public void pretendBaseCollision(int sequenceNumber) {
		/*
		 * ‘a number between 1-9’– PRETEND that the player robot has collided with the
		 * base number x (which must have a value between 1-9); tell the game world that
		 * this collision has occurred. The effect of moving over a base is to check to
		 * see whether the number x is exactly one greater than the base indicated by
		 * lastBaseReached field of the robot and if so to record in the robot the fact
		 * that the robot has now reached the next sequential base on the track (update
		 * the lastBaseReached field of the robot).
		 */
		for (GameObject gO : gameObjects) {
			if (gO instanceof Robot) {
				if (sequenceNumber == ((Robot) gO).getLastBaseReached()+1)
					((Robot) gO).updateLastBaseReached();
			} //else
				//ToastBar.showInfoMessage("Base number " + sequenceNumber + " is not the next base. proceded to base "
						//+ (((Robot) gO).getLastBaseReached() + 1) + ".");
		}

	}

	public void pretendEnergyStationCollision() {
		/*
		 * ‘e’ – PRETEND that the player robot has collided with (intersected with) an
		 * energy station; tell the game world that this collision has occurred. The
		 * effect of colliding an energy station is to increase the robot’s energy level
		 * by the capacity of the energy station, reduce the capacity of the energy
		 * station to zero, fade the color of the energy station (e.g., change it to
		 * light green), and add a new energy station with randomly-specified size and
		 * location into the game.
		 */
		// For purpose of the simulation since i there are a random amout of energy
		// stations i want to randomly pick which station is collided with. this loop
		// will be removed after the game is fully implemented.
		Random random = new Random();
		int pickedStation;
		final ArrayList<EnergyStation> energyStationList = new ArrayList<EnergyStation>();
		for (GameObject eS : gameObjects) {
			if (eS instanceof EnergyStation) {
				energyStationList.add((EnergyStation) eS);
			}
		}
		// Randomly selecting which station to collide Robot with
		pickedStation = random.nextInt(energyStationList.size()) + 1;

		for (GameObject gO : gameObjects) {
			if (gO instanceof Robot) {
				// finding instance of robot, charging Robot to capacity of randonly selected
				// EnergyStation then reducing EnergyStations Calapity to ZERO.
				((Robot) gO).chargeRobot(energyStationList.get(pickedStation).getCapacity());
				energyStationList.get(pickedStation).transferEnergy();
			}
		}
		energyStation = new EnergyStation();
		gameObjects.add(energyStation);
	}

	public void pretendRobotCollision() {
		/*
		 * ‘c’ – PRETEND that the player robot has collided with some other robot; tell
		 * the game world that this collision has occurred. (For this version of the
		 * program we won’t actually have any other robot in the simulation, but we need
		 * to provide for testing the effect of such collisions.) Colliding with another
		 * robot increases the damage level of the player robot and fades the color of
		 * the robot (i.e., the robot color becomes lighter red – throughout the game,
		 * the robot will have different shades of red); if the damage results in the
		 * player robot not being able to move then the game stops (the player loses a
		 * life).
		 */
		// Because there are no additional Robot objects the apply damage method will be
		// called and damage will be applied. damage is double the damage applied when a
		// drone collides with the player Robot
		int fakeRobot = 20;
		for(GameObject robot : gameObjects) {
			if(robot instanceof Robot) {
				((Robot) robot).applyDamage(fakeRobot);
			}
		}
	}

	public void pretendDroneCollision() {
		/*
		 * ‘g’ – PRETEND that a drone has flown over (collided with, gummed up) the
		 * player robot. The effect of colliding with a drone is to increase the damage
		 * to the robot as described above under the description of drones and fades the
		 * color of the robot (i.e., the robot color becomes lighter red).
		 */
		Random random = new Random();
		int pickedDrone;
		final ArrayList<Drone> droneList = new ArrayList<Drone>();
		for (GameObject drone : gameObjects) {
			if (drone instanceof Drone) {
				droneList.add((Drone) drone);
			}
		}
		// Randomly selecting which Drone to collide Robot with
		pickedDrone = random.nextInt(droneList.size());

		for (GameObject gO : gameObjects) {
			if (gO instanceof Robot) {
				((Robot) gO).applyDamage(droneList.get(pickedDrone).getAttack());
			}
		}

	}

	public void exit() {
		System.exit(0);
	}

}
