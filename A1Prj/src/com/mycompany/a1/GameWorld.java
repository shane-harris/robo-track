package com.mycompany.a1;

import java.util.ArrayList;
import java.util.Random;

import com.codename1.ui.geom.Point2D;

public class GameWorld {
	private ArrayList<GameObject> gameObjects;
	private double width;
	private double height;
	private double originX;
	private double originY;
	private Point2D point;
	private int clock;
	private int lives;
	private Random random = new Random();
	private EnergyStation energyStation;
	private Drone drone;
	private Base base;
	

	public GameWorld() {
		this.width = 1024.0;
		this.height = 768.0;
		this.originX = 0.0;
		this.originY = 0.0;
		this.point = new Point2D(originX,originY);

	}

	public void init() {
		gameObjects = new ArrayList<GameObject>();
		this.lives = 3;
		this.clock = 0;
		
		gameObjects.add(Robot.getRobot());
		for(int i=0; i<random.nextInt(5)+1;i++) {
			drone = new Drone();
			gameObjects.add(drone);
		}
		
		for(int i=0; i<random.nextInt(6)+1;i++) {
			energyStation = new EnergyStation();
			gameObjects.add(energyStation);
		}
		base = new Base(point,1);
		gameObjects.add(base);
		
		point = new Point2D(110,131);
		base = new Base(point, 2);
		gameObjects.add(base);
		
		point = new Point2D(200,191);
		base = new Base(point, 3);
		gameObjects.add(base);
		
		point = new Point2D(321,331);
		base = new Base(point, 4);
		gameObjects.add(base);
		
		point = new Point2D(610,631);
		base = new Base(point, 5);
		gameObjects.add(base);

	}

	public void tick() {
		/*
		 * ‘t’ – tell the game world that the “game clock” has ticked. A clock tick in
		 * the game world has the following effects: (1) if the player robot moves
		 * (e.g., did not run out of energy or does not have the maximum damage or zero
		 * speed), then the robot’s heading should be incremented or decremented by the
		 * robot’s steeringDirection (that is, the steering wheel turns the robot) (2)
		 * Drones also update their heading as indicated above. (3) all moveable objects
		 * are told to update their positions according to their current heading and
		 * speed, and (4) the robot’s energy level is reduced by the amount indicated by
		 * its energyConsumptionRate. (5) the elapsed time “game clock” is incremented
		 * by one (the game clock for this assignment is simply a variable which
		 * increments with each tick)
		 */

	}

	public void display() {
		/*
		 * ‘d’ – generate a display by outputting lines of text on the console
		 * describing the current game/player-robot state values. The display should
		 * include (1) the number of lives left, (2) the current clock value (elapsed
		 * time), (3) the highest base number the robot has reached sequentially so far,
		 * (4) the robot’s current energy level and (5) robot’s current damage level.
		 * All output should be appropriately labeled in easily readable format.
		 */

	}

	public void map() {
		/*
		 * ‘m’ – tell the game world to output a “map” showing the current worl For this
		 * assignment all output will be in text form on the console; no “graphical”
		 * output is required. The “map” (generated by the ‘m’ command) will simply be a
		 * set of lines describing the objects currently in the world, similar to the
		 * following: Base: loc=200.0,200.0 color=[0,0,255] size=10 seqNum=1 Base:
		 * loc=200.0,800.0 color=[0,0,255] size=10 seqNum=2 Base: loc=700.0,800.0
		 * color=[0,0,255] size=10 seqNum=3 Base: loc=900.0,400.0 color=[0,0,255]
		 * size=10 seqNum=4 Robot: loc=180.2,450.3 color=[255,0,0] heading=355 speed=50
		 * size=40 maxSpeed=50 steeringDirection=5 energyLevel=5 damageLevel=2 Drone:
		 * loc=70.3,70.7 color=[255,0,255] heading=45 speed=5 size=25 Drone:
		 * loc=950.6,950.3 color=[255,0,255] heading=225 speed=10 size=20 EnergyStation:
		 * loc=350.8,350.6 color=[0,255,0] size=15 capacity=15 EnergyStation:
		 * loc=900.0,700.4 color=[0,255,0] size=20 capacity=20
		 * 
		 * Note that the above “map” describes the game shortly after it has started;
		 * the robot has moved northward from its initial position at base #1, the robot
		 * is traveling at its maximum speed, the player is trying to apply a 5-degree
		 * right turn, and so forth. Note also that the appropriate mechanism for
		 * implementing this output is to override the toString() method in each
		 * concrete game object class so that it returns a String describing itself (see
		 * the “Appendix – CN1 Notes” below). Please see “Appendix – CN1 Notes” below
		 * for also tips on how to print one digit after a decimal point in CN1.
		 */

	}

	public void update() {

	}

	public void accelerate() {
		/*
		 * ‘a’ – tell the game world to accelerate (immediately increase the speed of)
		 * the player robot by a small amount. Note that the effect of acceleration is
		 * to be limited based on damage level, energy level, and maximum speed as
		 * described above.
		 */
	}

	public void brake() {
		/*
		 * ‘b’ – tell the game world to brake (immediately reduce the speed of) the
		 * player robot by a small amount. Note that the minimum speed for a robot is
		 * zero.
		 */
	}

	public void steerRight() {
		/*
		 * ‘r’ – tell the game world to change the steering direction of the player
		 * robot by 5 degrees to the right (in the positive direction on the compass).
		 * As above, this changes the direction of the robot’s steering wheel, not the
		 * robot’s heading
		 */

	}

	public void steerLeft() {
		/*
		 * Should call a method in the Robot object that steers left... ‘l’ (the letter
		 * “ell”) – tell the game world to change the steering direction of the player
		 * robot by 5 degrees to the left (in the negative direction on the compass).
		 * Note that this changes the direction of the robot’s steering wheel; it does
		 * not directly (immediately) affect the robot’s heading. See the “tick”
		 * command, below.
		 */
	}

	public void pretendBaseCollision(int num) {
		/*
		 * ‘a number between 1-9’– PRETEND that the player robot has collided with the
		 * base number x (which must have a value between 1-9); tell the game world that
		 * this collision has occurred. The effect of moving over a base is to check to
		 * see whether the number x is exactly one greater than the base indicated by
		 * lastBaseReached field of the robot and if so to record in the robot the fact
		 * that the robot has now reached the next sequential base on the track (update
		 * the lastBaseReached field of the robot).
		 */

	}

	public void pretendEnergyStationCollision() {
		/*
		 * ‘e’ – PRETEND that the player robot has collided with (intersected with) an
		 * energy station; tell the game world that this collision has occurred. The
		 * effect of colliding an energy station is to increase the robot’s energy level
		 * by the capacity of the energy station, reduce the capacity of the energy
		 * station to zero, fade the color of the energy station (e.g., change it to
		 * light green), and add a new energy station with randomly-specified size and
		 * location into the game.
		 */

	}

	public void pretendRobotCollision() {
		/*
		 * ‘c’ – PRETEND that the player robot has collided with some other robot; tell
		 * the game world that this collision has occurred. (For this version of the
		 * program we won’t actually have any other robot in the simulation, but we need
		 * to provide for testing the effect of such collisions.) Colliding with another
		 * robot increases the damage level of the player robot and fades the color of
		 * the robot (i.e., the robot color becomes lighter red – throughout the game,
		 * the robot will have different shades of red); if the damage results in the
		 * player robot not being able to move then the game stops (the player loses a
		 * life).
		 */
	}

	public void pretendDroneCollision() {
		/*
		 * ‘g’ – PRETEND that a drone has flown over (collided with, gummed up) the
		 * player robot. The effect of colliding with a drone is to increase the damage
		 * to the robot as described above under the description of drones and fades the
		 * color of the robot (i.e., the robot color becomes lighter red).
		 */

	}

	public void exit() {
		System.exit(0);
	}

}
